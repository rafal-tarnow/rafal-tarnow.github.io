<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			margin: 0;
		}
	</style>
	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>
  <script type="module" crossorigin src="/T_Engine/dist/assets/index-CPNVrWpF.js"></script>
</head>

<body>
	<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - earth [fly
		controls]<br />
		<b>WASD</b> move, <b>R|F</b> up | down, <b>Q|E</b> roll, <b>up|down</b> pitch, <b>left|right</b> yaw
	</div>
</body>

</html>


<!-- <!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry - shapes</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #f0f0f0;
			color: #444;
		}
	</style>
</head>

<body>

	<div id="info">Simple procedurally-generated shapes</div>



	<script type="module">

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';

		let container, stats;

		let camera, scene, renderer;

		let group;

		let targetRotation = 0;
		let targetRotationOnPointerDown = 0;

		let pointerX = 0;
		let pointerXOnPointerDown = 0;

		let windowHalfX = window.innerWidth / 2;

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xf0f0f0);

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(0, 150, 500);
			scene.add(camera);

			const light = new THREE.PointLight(0xffffff, 2.5, 0, 0);
			camera.add(light);

			group = new THREE.Group();
			group.position.y = 50;
			scene.add(group);

			const loader = new THREE.TextureLoader();
			const texture = loader.load('textures/uv_grid_opengl.jpg');
			texture.colorSpace = THREE.SRGBColorSpace;

			// it's necessary to apply these settings in order to correctly display the texture on a shape geometry

			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(0.008, 0.008);

			function addTexturedShape(mgroup, shape, mtexture, x, y, z, rx, ry, rz, s) {

				// flat shape with texture
				// note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

				let geometry = new THREE.ShapeGeometry(shape);

				let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: mtexture, wireframe: false }));
				mesh.position.set( x, y, z - 175 );
				mesh.rotation.set( rx, ry, rz );
				mesh.scale.set( s, s, s );
				mgroup.add( mesh );
			}

			function addFlatShape(mgroup, shape, color, x, y, z, rx, ry, rz, s) {
				// flat shape

				let geometry = new THREE.ShapeGeometry(shape);

				let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide, wireframe: false }));
				mesh.position.set(x, y, z - 125);
				mesh.rotation.set(rx, ry, rz);
				mesh.scale.set(s, s, s);
				mgroup.add(mesh);
			}

			function addLineShape(mgroup, shape, color, x, y, z, rx, ry, rz, s) {

				// lines

				shape.autoClose = true;

				const points = shape.getPoints();
				const spacedPoints = shape.getSpacedPoints(50);

				const geometryPoints = new THREE.BufferGeometry().setFromPoints(points);
				const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints(spacedPoints);

				// solid line

				let line = new THREE.Line(geometryPoints, new THREE.LineBasicMaterial({ color: color }));
				line.position.set(x, y, z - 25);
				line.rotation.set(rx, ry, rz);
				line.scale.set(s, s, s);
				mgroup.add(line);

			}


			//QML
			const qmlRect = new THREE.Shape();

			(function qmlRect(ctx, x, y, width, height) {
				ctx.moveTo(0, 0)
				ctx.lineTo(0, height)
				ctx.lineTo(width, height)
				ctx.lineTo(width, 0)
				ctx.lineTo(0, 0);
			})(qmlRect, 0, 0, 100, 100);

			addFlatShape(group, qmlRect, 0x008000, 0, 75, 0, 0, 0, 0, 1);
			addTexturedShape(group, qmlRect, texture, 0, 75, 0, 0, 0, 0, 1);
			addLineShape(group, qmlRect, 0x008000, 0, 75, 0, 0, 0, 0, 1);

			// Square

			const sqLength = 80;

			const squareShape = new THREE.Shape()
				.moveTo(0, 0)
				.lineTo(0, sqLength)
				.lineTo(sqLength, sqLength)
				.lineTo(sqLength, 0)
				.lineTo(0, 0);

			// Rounded rectangle




			const roundedRectShape = new THREE.Shape();

			(function roundedRect(ctx, x, y, width, height, radius) {

				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y + height - radius);
				ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
				ctx.lineTo(x + width - radius, y + height);
				ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
				ctx.lineTo(x + width, y + radius);
				ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.quadraticCurveTo(x, y, x, y + radius);

			})(roundedRectShape, 0, 0, 50, 50, 5);




			//

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			container.style.touchAction = 'none';
			container.addEventListener('pointerdown', onPointerDown);

			//

			window.addEventListener('resize', onWindowResize);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function onPointerDown(event) {

			if (event.isPrimary === false) return;

			pointerXOnPointerDown = event.clientX - windowHalfX;
			targetRotationOnPointerDown = targetRotation;

			document.addEventListener('pointermove', onPointerMove);
			document.addEventListener('pointerup', onPointerUp);

		}

		function onPointerMove(event) {

			if (event.isPrimary === false) return;

			pointerX = event.clientX - windowHalfX;

			targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;

		}

		function onPointerUp() {

			if (event.isPrimary === false) return;

			document.removeEventListener('pointermove', onPointerMove);
			document.removeEventListener('pointerup', onPointerUp);

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
			renderer.render(scene, camera);

		}

	</script>

</body>

</html> -->